/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */
package ch.usi.inf.sa2.CookieCrumbles;

import java.awt.Color;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.Rectangle;
import java.awt.Shape;
import java.awt.geom.Ellipse2D;
import java.awt.geom.Rectangle2D;
import java.util.ArrayList;
import java.util.Random;

/**
 *
 * @author alexm
 */
public class ParticleEmitterBH {
    private int particleCount;
     double originX;
     double originY;
    private ArrayList particleList;
    Rectangle boundingBox;
    CCWall wall;
    CCWall wall2;
    ////Fields for Black Hole
    private double azimuthCounter = 0;
    private int azimuthTimes = 0;
    private double spread;
    private double direction;
    private int density;
 
    /**
     *
     * @param originX
     * @param originY
     * @param particleCount
     */
    public ParticleEmitterBH(double originX, double originY, int particleCount){
        this.particleCount = particleCount;
        this.originX = originX;
        this.originY = originY;
        boundingBox = new Rectangle((int) originX,(int) originY,35,35);
        particleList  = new ArrayList();    
        wall2 = new CCWall (2600,900, 300, 3.14);
        wall = new CCWall(2200, 500, 300 ,  3.14/3 - 1.17654345678);
        spread = 3.14;
        direction = 0;
        density = 10;
    }
   
     /**
     *
     * @return
     */
    public double lengthRandomizer() {
        Random rand = new Random();
        double randomNum = rand.nextInt(55);
        return randomNum;
    }
     
    public double azimuthRandomizer() {
        Random rand = new Random();
        double randomNum = rand.nextInt(5);
        //System.out.println(randomNum);
        return randomNum/500;
    }
    
    public double getAzimuthFromGivenCartesian(double x, double y) {
        double azimuthC = Math.atan2(y, x);
        azimuthC = Math.toDegrees(azimuthC);
        //System.out.println(azimuth);
        return azimuthC;
    }
    
     public Rectangle getBoundingBox(){
         return boundingBox;
         
     }
     
     public void setBoundingBox(Rectangle rect){
         boundingBox = rect; 
     }
    
     
    /**
     *
     * @return
     */
    public double directionRandomizer() {
        Random rand = new Random();
        double min = direction;
        double max = spread/10;  //180 degreees!!
        double randomNum = min + (max - min) * rand.nextDouble();
        
        return randomNum;
    }
    
    public double getOriginX(){
        return originX;
    }
    
      public void setDirection(double dir){
         direction = dir;
     }
     
     public void setSpread(double spr){
         spread = spr;
     }
     
     public void setDensity(int den){
         density = den;
     }
    /**
     *
     * @return
     */
    public double getOriginY(){
        return originY;
    }
    
    /**
     *
     * @param shiftXBy
     */
    public void setOriginX(double shiftXBy){
        originX = shiftXBy;
    }
    
    public void setOriginY ( double shiftYBy){
        originY = shiftYBy;
    }
    
    /**
     *
     * @param hi
     */
    public void setParticleList(ArrayList hi){
        particleList = hi;
    }
    
    
    /**
     *
     * @return
     */
    public ArrayList getParticleList(){
        return particleList;
    } 
    /*
     * Sets a number of particles generated by Particle 
     * emitter object.
     */
    public void setParticleCount( final int newCount){
        particleCount = newCount;
    }
   
    
    /**
     *
     * @return
     */
    public int getParticleCount() {
        return particleCount;
    }
    
   public double azimuthBetweenTwoPoints(double x1,double y1, double x2, double y2) {
        double dx = x2 -x1;
        double dy = y2- y1;
        double result;
        if(dx > 0) {
            result = (Math.PI*0.5)- Math.atan(dy/dx);
        result = Math.toDegrees(result);
        
        return result;
        }
        if(dx < 0) {
            result = (Math.PI*1.5) - Math.atan(dy/dx);
            result = Math.toDegrees(result);
            //System.out.println(result);
        
            return result;}
        if(dy > 0) {
            result =0;
            result = Math.toDegrees(result);
            //System.out.println(result);
            return result;}
        if(dy < 0) {
            result = Math.PI;
            result = Math.toDegrees(result);
            //System.out.println(result);
            return result;}
        else {
            result = -999;
            //System.out.println(result);
        }
        result = Math.toDegrees(result);
        
        return result;

        
    
    }
    
   
    /**
     *
     * @param gr
     */
    public void recalculate(final Graphics gr){
        Graphics2D g = (Graphics2D) gr;
        wall.drawWall(g);
        
        wall2.drawWall(g);
        g.setPaint(Color.BLACK);
        BlackHole BH = new BlackHole(1200, -600);
            
            Shape BHShape = new Ellipse2D.Double(BH.getX(), BH.getY(), 240, 240);
            g.draw(BHShape);
            g.fill(BHShape);
            Shape BHInv = new Ellipse2D.Double(BH.getX()- BH.getX()/2.5, BH.getY()+BH.getY()/1.5, 1200, 1200);
        for (int i = 0; i <density; i++) {
            
        
        Particle myparticle = new Particle(originX+20, originY+15, originX+20 ,originY+15, directionRandomizer(), /// In radians
                0, 90, 
                lengthRandomizer(), (int)lengthRandomizer()*10);
        Shape particleNew = new Rectangle((int) originX,
                    (int) originY, 15, 15);
            myparticle.setParticleRect(particleNew);
        particleList.add(myparticle);
        
        
        
        }
        double changeAzi = 0;
        for (int i = 0; i < particleList.size(); i++) {
            Particle part = (Particle) particleList.get(i);
            Shape wallLine = wall.getWallShape();
            //System.out.println("" + part.getEmitterOriginX()+" " + part.getEmitterOriginY());
            Shape wallline2 = wall2.getWallShape();
            Shape particleRect2 = part.getParticleRect();
            Rectangle2D particleRect = particleRect2.getBounds2D();
            ///Black Hole
            double partInitValuesLength = (part.getPosition().getLength());
            double length = part.getPosition().getLength();
            
        
            
            
            changeAzi += 0.0000000000000000;
            if(BHInv.contains(particleRect)){
                //part.getPosition().setAzi(part.getPosition().getAzimuth()- changeAzi);
                //part.setVelocity(part.getVelocity()- part.getVelocity()/6);
                
                
                //azimuthBetweenTwoPoints(partX, partY, BH.getX(), BH.getY());
                //System.out.println(part.getPosition().getAzimuth());
                //System.out.println(azimuthBetweenTwoPoints(partX, partY, BH.getX(), BH.getY()));
                double newOriginX = part.positionGetX()+part.getEmitterOriginX();
                double newOriginY = part.positionGetY()+part.getEmitterOriginY();
                part.setOriginX(newOriginX);
                part.setOriginY(newOriginY);
                part.setPosition(part.getPositionReset());
                double partX =part.getPosition().getX();
                double partY = part.getPosition().getY();
                //System.out.println(part.getPosition().getAzimuth());
                part.getPosition().setAzi(-Math.toRadians((azimuthBetweenTwoPoints(partX, partY, BH.getX(), BH.getY()))*newOriginX/1300)/1.545);
                //System.out.println(part.getPosition().getAzimuth());
            }
            if(BHShape.contains(particleRect)){
                part.setLifetime(201);
            }
            
            if(part.getPosition().getAzimuth()<3.14/2){
                //part.getPosition().setAzi(Math.toRadians(grav));
                part.getPosition().setAzi(part.getPosition().getAzimuth() -(part.getPosition().getAzimuth() - partInitValuesLength)/1000000);
            }
             if(part.getPosition().getAzimuth()>3.14/2){
                //part.getPosition().setAzi(Math.toRadians(grav));
                 
                part.getPosition().setAzi(part.getPosition().getAzimuth() +(part.getPosition().getAzimuth() - partInitValuesLength)/1000000);
                
             }
             if(part.getPosition().getAzimuth()==0.5 || part.getPosition().getAzimuth()==1.5){
                    part.setLifetime(201);
                }
//            if(1 == 1){
//    part.getPosition().setAzi(part.getPosition().getAzimuth() -(part.getPosition().getAzimuth() - partInitValuesLength)/2000000);
//    }
             
            
            
            //if(1 == 1){
              //  part.getPosition().setAzi(part.getPosition().getAzimuth() -(part.getPosition().getAzimuth() - partInitValuesLength)/5000000);
            //}
//                //part.positionValue.j.setAzimuth(azimuth- (part.initValues.getAzimuth() - partInitValuesLength)/1000000); //+ partInitValuesAzimuth/5000);
//                //if(part.positionValue.j.getAzimuth() > 1) {
//                  //  particleList.remove(part);
//                //}
//                if(part.getPosition().getAzimuth() > 1){
//                    particleList.remove(part);
//                }
//                if(part.positionGetY()< BH.getY()-150){
//                    part.setLifetime(206);
//                }
//                
//                if(part.positionGetX() > BH.getX()/2 && part.positionGetY() < BH.getY()-BH.getY()*1.2) {
//                    //part.setVelocity(part.getVelocity()+ part.getVelocity()/4);
//                if(part.positionGetX()>(BH.getX()+BH.getX())/1.5 && part.positionGetY()< BH.getY()+100){
//                    part.setVelocity(part.getVelocity()-BH.getX()/700); ////!!!!!!!!!!!!
//                   //part.getPosition().setAzi(length + length/2);
//                        part.setLifetime(199);
//                        //System.out.println("HEY");
//                    
//                    //System.out.println(part.getPosition().getLength());
//                    //part.getPosition().setAzi(getAzimuthFromGivenCartesian(1200, -600)+ part.getPosition().getAzimuth());//part.getPosition().getAzimuth()+part.getPosition().getAzimuth()/7);
//                    //part.setNewPosition();
//                    //part.initValues.j.setAzimuth(2);
//                    //part.initValues.j.setLength(length-BH.getX()/700);
//                    
//
//                    //part.setLifetime(199);
//                    
//                }
//                   
//                    //part.initValues.add(part.initValues);  !!!!!!!!!!!!!
//                        if(part.getPosition().getAzimuth() - azimuthCounter < Math.toRadians(part.getPosition().getAzimuthFromGivenCartesian(BH.getX(), BH.getY()))+3){
//                            part.getPosition().setAzi(part.getPosition().getAzimuth() - azimuthCounter);
//                        }
////                        if(part.positionGetX()== BH.getX()+200) {
////                        System.out.println("hey");
////                        //part.setLifetime(201);
//                    
//                }
//            }
//            azimuthTimes += 0.1;
//                azimuthCounter = azimuthRandomizer();
//            
//            
            ////END OF BLACK HOLE
            
            
            if (wallLine.intersects(particleRect)){
                double newOriginX =  part.positionGetX() + part.getEmitterOriginX() ;
                double newOriginY =  part.positionGetY() + part.getEmitterOriginY() ;
                part.setOriginX(newOriginX);
                part.setOriginY(newOriginY);
                CCVector reflected = wall.calculateReflected(part.getPositionReset(), newOriginX, newOriginY);
                part.setPosition(reflected);
                g.setPaint(Color.BLACK);
                Shape particleNew = new Rectangle((int) part.getEmitterOriginX()  ,
                    (int)part.getEmitterOriginY() , 15,15);
                part.setParticleRect(particleNew);
                
                g.fill(particleNew);
                part.setLifetime(155);
                
                
            }
            
            //// TO DELETE LATER MOTHERFUCKA
            
            if (wallline2.intersects(particleRect)){
                double newOriginX =  part.positionGetX() + part.getEmitterOriginX() ;
                double newOriginY =  part.positionGetY() + part.getEmitterOriginY() ;
                part.setOriginX(newOriginX);
                part.setOriginY(newOriginY);
                CCVector reflected = wall2.calculateReflected(part.getPositionReset(), newOriginX, newOriginY);
                part.setPosition(reflected);
                
                g.setPaint(Color.BLACK);
                Shape particleNew = new Rectangle((int) part.getEmitterOriginX()  ,
                    (int)part.getEmitterOriginY() , 15,15);
                part.setParticleRect(particleNew);
                g.fill(particleNew);
                part.setLifetime(155);
                
                
            }
            
            
            
            
            
            
            
            /////////// TILL HERE 
            
            
            
            
            int lifetime = part.getLifetime();
            lifetime++;
            part.setLifetime(lifetime);
            part.setNewPosition();
            double x = part.positionGetX();
            double y = part.positionGetY();
            g.setPaint(Color.BLACK);
            //// TEST 
           
            
            
            
            Shape particleNew = new Rectangle((int) part.getEmitterOriginX() + (int)x,
                    (int)part.getEmitterOriginY() +(int)y, 15,15);
            part.setParticleRect(particleNew);
            g.fill(particleNew);
            if (lifetime > 200) {
                particleList.remove(part);
                part = null;
            }
            
            }
        
                
        
           
    
}

}
